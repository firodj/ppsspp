package main

// #cgo CFLAGS: -I${INCLUDE_PATH}
// #cgo LDFLAGS: ${LIBRARY_PATH} -lstdc++
/*
#include <go_bridge.h>

char * bridgeGetFuncName(int moduleIndex, int funcIndex);
*/
import "C"
import (
	"fmt"
	"sync"
	"unsafe"
)

type bridgeSymbolMap C.BridgeSymbolMap
type bridgeMipsOpcodeInfo C.BridgeMipsOpcodeInfo
type funcGetFuncName func(int, int) string

var g_GetFuncName funcGetFuncName = nil
var g_AllocatedCString []*C.char = nil
var m sync.Mutex
var g_memoryBase unsafe.Pointer = nil

func FreeAllocatedCString() {
  m.Lock()
  defer m.Unlock()

  for _, cstr := range g_AllocatedCString {
    C.free(unsafe.Pointer(cstr))
  }
  g_AllocatedCString = nil
}

func AllocateCString(str string) *C.char {
  m.Lock()
  defer m.Unlock()

  cstr := C.CString(str)
  g_AllocatedCString = append(g_AllocatedCString, cstr)
  return cstr
}

func GlobalSetMemoryBase(data []byte, startAddress uint32) unsafe.Pointer {
  g_oldMemoryBase := g_memoryBase
  if g_oldMemoryBase != nil {
    defer C.free(g_oldMemoryBase)
  }

  if data == nil {
    g_memoryBase = nil
  } else {
    g_memoryBase = C.CBytes(data)
  }

  C.GlobalSetMemoryBase(g_memoryBase, C.uint32_t(startAddress))
  return g_memoryBase
}

func NewSymbolMap() bridgeSymbolMap {
  return bridgeSymbolMap(C.NewSymbolMap())
}

func DeleteSymbolMap(symmap bridgeSymbolMap) {
  C.DeleteSymbolMap(C.BridgeSymbolMap(symmap))
}

func SymbolMap_GetFunctionSize(symmap bridgeSymbolMap, startAddress uint32) uint32 {
  return uint32(C.SymbolMap_GetFunctionSize(
    C.BridgeSymbolMap(symmap), C.uint32_t(startAddress),
  ))
}

func SymbolMap_GetFunctionStart(symmap bridgeSymbolMap, address uint32) uint32 {
  return uint32(C.SymbolMap_GetFunctionStart(
    C.BridgeSymbolMap(symmap), C.uint32_t(address),
  ))
}

func SymbolMap_GetLabelName(symmap bridgeSymbolMap, address uint32) *string {
  cstr := C.SymbolMap_GetLabelName(
    C.BridgeSymbolMap(symmap), C.uint32_t(address),
  )
  if cstr == nil {
    return nil
  }
  str := C.GoString(cstr)
  return &str
}

func SymbolMap_AddFunction(symmap bridgeSymbolMap, name string, address uint32, size uint32, moduleIndex int) {
  nameStr := C.CString(name)
  defer C.free(unsafe.Pointer(nameStr))

  C.SymbolMap_AddFunction(
    C.BridgeSymbolMap(symmap),
    nameStr,
    C.uint32_t(address),
    C.uint32_t(size),
    C.int(moduleIndex),
  )
}

func SymbolMap_AddModule(symmap bridgeSymbolMap, name string, address uint32, size uint32) {
  nameStr := C.CString(name)
  defer C.free(unsafe.Pointer(nameStr))

  C.SymbolMap_AddModule(
    C.BridgeSymbolMap(symmap),
    nameStr,
    C.uint32_t(address),
    C.uint32_t(size),
  )
}

func GlobalSetSymbolMap(symmap bridgeSymbolMap) {
  C.GlobalSetSymbolMap(C.BridgeSymbolMap(symmap))
}

//export bridgeGetFuncName
func bridgeGetFuncName(moduleIndex C.int, funcIndex C.int) *C.char {
  if g_GetFuncName == nil {
    fmt.Printf("WARNING:\tg_GetFuncName is nil")
    return nil
  }
  str := g_GetFuncName(int(moduleIndex), int(funcIndex))
  if str == "" {
    return nil
  }
  return AllocateCString(str)
}

func GlobalSetGetFuncNameFunc(fn funcGetFuncName) {
  g_GetFuncName = fn
  if fn != nil {
    C.GlobalSetGetFuncNameFunc(C.GetFuncNameFunc(C.bridgeGetFuncName))
  } else {
    C.GlobalSetGetFuncNameFunc(nil)
  }
}

func MemoryIsValidAddress(address uint32) bool {
  return C.MemoryIsValidAddress(C.uint32_t(address)) == 1
}

func MIPSAnalystGetOpcodeInfo(address uint32) bridgeMipsOpcodeInfo {
  return bridgeMipsOpcodeInfo(C.MIPSAnalystGetOpcodeInfo(C.uint32_t(address)))
}

func MipsOpcodeInfoString(opcode_info bridgeMipsOpcodeInfo) (string, string) {
  return C.GoString(&opcode_info.dizz[0]), C.GoString(&opcode_info.log[0])
}
